package generator

import (
	"fmt"
	"strings"

	"github.com/gaoubak/Makegen/internal/config"
	"github.com/gaoubak/Makegen/internal/utils"
)

// Builder generates Makefile content
type Builder struct {
	logger *utils.Logger
}

// NewBuilder creates a new builder
func NewBuilder(logger *utils.Logger) *Builder {
	return &Builder{
		logger: logger,
	}
}

// Build generates the complete Makefile content
func (b *Builder) Build(cfg *config.MakefileConfig) (string, error) {
	var content strings.Builder

	// Header
	b.writeHeader(&content, cfg)

	// Variables
	b.writeVariables(&content, cfg)

	// Help target
	b.writeHelpTarget(&content)

	// Build targets
	b.writeBuildTargets(&content, cfg)

	// Test targets
	b.writeTestTargets(&content, cfg)

	// Lint targets
	b.writeLintTargets(&content, cfg)

	// Format targets
	b.writeFormatTargets(&content, cfg)

	// Docker targets
	if cfg.HasDocker {
		b.writeDockerTargets(&content, cfg)
	}

	// CI/CD targets
	if cfg.EnableCI {
		b.writeCITargets(&content)
	}

	// Deploy targets
	if cfg.EnableDeploy {
		b.writeDeployTargets(&content)
	}

	// Custom targets
	b.writeCustomTargets(&content, cfg)

	return content.String(), nil
}

func (b *Builder) writeHeader(w *strings.Builder, cfg *config.MakefileConfig) {
	fmt.Fprintf(w, "# Generated Makefile\n")
	fmt.Fprintf(w, "# Project: %s\n", cfg.ProjectName)
	fmt.Fprintf(w, "# Language: %s\n", cfg.Language)
	if cfg.Framework != nil {
		fmt.Fprintf(w, "# Framework: %s\n", cfg.Framework.Name)
	}
	fmt.Fprintf(w, "# Auto-generated by makegen\n\n")
}

func (b *Builder) writeVariables(w *strings.Builder, cfg *config.MakefileConfig) {
	fmt.Fprintf(w, "# Variables\n")
	fmt.Fprintf(w, "PROJECT_NAME := %s\n", cfg.ProjectName)
	fmt.Fprintf(w, "VERSION := 1.0.0\n")

	// Language-specific variables
	switch cfg.Language {
	case "go":
		fmt.Fprintf(w, "GO := go\n")
		fmt.Fprintf(w, "GOFLAGS := -v\n")
		fmt.Fprintf(w, "OUT_DIR := bin\n")
	case "javascript":
		fmt.Fprintf(w, "NPM := npm\n")
		fmt.Fprintf(w, "NODE := node\n")
	case "python":
		fmt.Fprintf(w, "PYTHON := python3\n")
		fmt.Fprintf(w, "PIP := pip3\n")
	}

	if cfg.HasDocker {
		fmt.Fprintf(w, "DOCKER := docker\n")
		fmt.Fprintf(w, "DOCKER_IMAGE := %s\n", cfg.DockerImage)
	}

	fmt.Fprintf(w, "\n")
}

func (b *Builder) writeHelpTarget(w *strings.Builder) {
	fmt.Fprintf(w, ".PHONY: help\n\n")
	fmt.Fprintf(w, "help:\n")
	fmt.Fprintf(w, "\t@echo \"$(PROJECT_NAME) - Makefile Targets\"\n")
	fmt.Fprintf(w, "\t@echo \"Usage: make <target>\"\n")
	fmt.Fprintf(w, "\t@echo \"\"\n")
	fmt.Fprintf(w, "\t@grep -E '^[a-zA-Z_-]+:' Makefile | sed 's/:$$//' | awk '{print \"  - \" $$1}'\n")
	fmt.Fprintf(w, "\t@echo \"\"\n\n")
}

func (b *Builder) writeBuildTargets(w *strings.Builder, cfg *config.MakefileConfig) {
	fmt.Fprintf(w, "# Build Targets\n")

	// TODO: Language-specific build targets
	switch cfg.Language {
	case "go":
		fmt.Fprintf(w, "build:\n")
		fmt.Fprintf(w, "\t$(GO) build $(GOFLAGS) -o $(OUT_DIR)/$(PROJECT_NAME) .\n")
		fmt.Fprintf(w, ".PHONY: build\n\n")

		fmt.Fprintf(w, "clean:\n")
		fmt.Fprintf(w, "\trm -rf $(OUT_DIR)\n")
		fmt.Fprintf(w, "\t$(GO) clean\n")
		fmt.Fprintf(w, ".PHONY: clean\n\n")

	case "javascript":
		fmt.Fprintf(w, "install:\n")
		fmt.Fprintf(w, "\t$(NPM) install\n")
		fmt.Fprintf(w, ".PHONY: install\n\n")

		fmt.Fprintf(w, "build:\n")
		fmt.Fprintf(w, "\t$(NPM) run build\n")
		fmt.Fprintf(w, ".PHONY: build\n\n")

	case "python":
		fmt.Fprintf(w, "install:\n")
		fmt.Fprintf(w, "\t$(PIP) install -r requirements.txt\n")
		fmt.Fprintf(w, ".PHONY: install\n\n")

		fmt.Fprintf(w, "clean:\n")
		fmt.Fprintf(w, "\tfind . -type f -name '*.pyc' -delete\n")
		fmt.Fprintf(w, "\tfind . -type d -name '__pycache__' -delete\n")
		fmt.Fprintf(w, ".PHONY: clean\n\n")
	}
}

func (b *Builder) writeTestTargets(w *strings.Builder, cfg *config.MakefileConfig) {
	if cfg.TestFramework == "" {
		return
	}

	fmt.Fprintf(w, "# Test Targets\n")

	switch cfg.TestFramework {
	case "go test":
		fmt.Fprintf(w, "test:\n")
		fmt.Fprintf(w, "\t$(GO) test -v ./...\n")
		fmt.Fprintf(w, ".PHONY: test\n\n")
	case "jest":
		fmt.Fprintf(w, "test:\n")
		fmt.Fprintf(w, "\t$(NPM) test\n")
		fmt.Fprintf(w, ".PHONY: test\n\n")
	case "pytest":
		fmt.Fprintf(w, "test:\n")
		fmt.Fprintf(w, "\t$(PYTHON) -m pytest\n")
		fmt.Fprintf(w, ".PHONY: test\n\n")
	}
}

func (b *Builder) writeLintTargets(w *strings.Builder, cfg *config.MakefileConfig) {
	if len(cfg.LintTools) == 0 {
		return
	}

	fmt.Fprintf(w, "# Lint Targets\n")
	fmt.Fprintf(w, "lint:\n")

	for _, tool := range cfg.LintTools {
		fmt.Fprintf(w, "\t%s\n", tool)
	}
	fmt.Fprintf(w, ".PHONY: lint\n\n")
}

func (b *Builder) writeFormatTargets(w *strings.Builder, cfg *config.MakefileConfig) {
	if len(cfg.FormatTools) == 0 {
		return
	}

	fmt.Fprintf(w, "# Format Targets\n")
	fmt.Fprintf(w, "format:\n")

	for _, tool := range cfg.FormatTools {
		fmt.Fprintf(w, "\t%s\n", tool)
	}
	fmt.Fprintf(w, ".PHONY: format\n\n")
}

func (b *Builder) writeDockerTargets(w *strings.Builder, cfg *config.MakefileConfig) {
	fmt.Fprintf(w, "# Docker Targets\n")
	fmt.Fprintf(w, "docker-build:\n")
	fmt.Fprintf(w, "\t$(DOCKER) build -t $(DOCKER_IMAGE):latest .\n")
	fmt.Fprintf(w, ".PHONY: docker-build\n\n")

	fmt.Fprintf(w, "docker-run: docker-build\n")
	fmt.Fprintf(w, "\t$(DOCKER) run -it --rm $(DOCKER_IMAGE):latest\n")
	fmt.Fprintf(w, ".PHONY: docker-run\n\n")

	if cfg.DockerCompose && len(cfg.DockerServices) > 0 {
		fmt.Fprintf(w, "docker-compose-up:\n")
		fmt.Fprintf(w, "\tdocker-compose up -d\n")
		fmt.Fprintf(w, ".PHONY: docker-compose-up\n\n")

		fmt.Fprintf(w, "docker-compose-down:\n")
		fmt.Fprintf(w, "\tdocker-compose down\n")
		fmt.Fprintf(w, ".PHONY: docker-compose-down\n\n")
	}
}

func (b *Builder) writeCITargets(w *strings.Builder) {
	fmt.Fprintf(w, "# CI/CD Targets\n")
	fmt.Fprintf(w, "ci: lint test\n")
	fmt.Fprintf(w, "\t@echo \"✓ All CI checks passed\"\n")
	fmt.Fprintf(w, ".PHONY: ci\n\n")
}

func (b *Builder) writeDeployTargets(w *strings.Builder) {
	fmt.Fprintf(w, "# Deploy Targets\n")
	fmt.Fprintf(w, "deploy: ci docker-build\n")
	fmt.Fprintf(w, "\t@echo \"✓ Deploy complete\"\n")
	fmt.Fprintf(w, ".PHONY: deploy\n\n")
}

func (b *Builder) writeCustomTargets(w *strings.Builder, cfg *config.MakefileConfig) {
	if len(cfg.CustomTargets) == 0 {
		return
	}

	fmt.Fprintf(w, "# Custom Targets\n")

	for _, target := range cfg.CustomTargets {
		fmt.Fprintf(w, "%s:", target.Name)
		if len(target.Dependencies) > 0 {
			fmt.Fprintf(w, " %s", strings.Join(target.Dependencies, " "))
		}
		fmt.Fprintf(w, "\n")

		for _, cmd := range target.Commands {
			fmt.Fprintf(w, "\t%s\n", cmd)
		}

		fmt.Fprintf(w, ".PHONY: %s\n\n", target.Name)
	}
}
